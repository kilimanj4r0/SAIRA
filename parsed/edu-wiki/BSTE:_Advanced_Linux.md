






BSTE: Advanced Linux
====================






Contents
--------


* [1 Advanced Linux: Understanding and programming](#Advanced_Linux:_Understanding_and_programming)
	+ [1.1 Short Description](#Short_Description)
	+ [1.2 Prerequisites](#Prerequisites)
		- [1.2.1 Prerequisite subjects](#Prerequisite_subjects)
		- [1.2.2 Prerequisite topics](#Prerequisite_topics)
	+ [1.3 Course Topics](#Course_Topics)
	+ [1.4 Intended Learning Outcomes (ILOs)](#Intended_Learning_Outcomes_.28ILOs.29)
		- [1.4.1 What is the main purpose of this course?](#What_is_the_main_purpose_of_this_course.3F)
		- [1.4.2 ILOs defined at three levels](#ILOs_defined_at_three_levels)
			* [1.4.2.1 Level 1: What concepts should a student know/remember/explain?](#Level_1:_What_concepts_should_a_student_know.2Fremember.2Fexplain.3F)
			* [1.4.2.2 Level 2: What basic practical skills should a student be able to perform?](#Level_2:_What_basic_practical_skills_should_a_student_be_able_to_perform.3F)
			* [1.4.2.3 Level 3: What complex comprehensive skills should a student be able to apply in real-life scenarios?](#Level_3:_What_complex_comprehensive_skills_should_a_student_be_able_to_apply_in_real-life_scenarios.3F)
	+ [1.5 Grading](#Grading)
		- [1.5.1 Course grading range](#Course_grading_range)
		- [1.5.2 Course activities and grading breakdown](#Course_activities_and_grading_breakdown)
		- [1.5.3 Recommendations for students on how to succeed in the course](#Recommendations_for_students_on_how_to_succeed_in_the_course)
	+ [1.6 Resources, literature and reference materials](#Resources.2C_literature_and_reference_materials)
		- [1.6.1 Open access resources](#Open_access_resources)
		- [1.6.2 Closed access resources](#Closed_access_resources)
		- [1.6.3 Software and tools used within the course](#Software_and_tools_used_within_the_course)
* [2 Teaching Methodology: Methods, techniques, & activities](#Teaching_Methodology:_Methods.2C_techniques.2C_.26_activities)
	+ [2.1 Activities and Teaching Methods](#Activities_and_Teaching_Methods)
	+ [2.2 Formative Assessment and Course Activities](#Formative_Assessment_and_Course_Activities)
		- [2.2.1 Ongoing performance assessment](#Ongoing_performance_assessment)
			* [2.2.1.1 Section 1](#Section_1)
			* [2.2.1.2 Section 2](#Section_2)
			* [2.2.1.3 Section 3](#Section_3)
			* [2.2.1.4 Section 4](#Section_4)
			* [2.2.1.5 Section 5](#Section_5)
			* [2.2.1.6 Section 6](#Section_6)
			* [2.2.1.7 Section 7](#Section_7)
			* [2.2.1.8 Section 8](#Section_8)
		- [2.2.2 Final assessment](#Final_assessment)
		- [2.2.3 The retake exam](#The_retake_exam)



Advanced Linux: Understanding and programming
=============================================


* **Course name**: Advanced Linux: Understanding and programming
* **Code discipline**: xxxxx
* **Subject area**:


Short Description
-----------------


This course covers the following concepts: • The fundamental principles for `booting`; • Linux Kernel: understanding, programming, debugging, contributing; • Device drivers; • Power management; • Graphical stack overview; • Userspace: understating and interaction with Kernel.



Prerequisites
-------------


### Prerequisite subjects


### Prerequisite topics


Course Topics
-------------




Course Sections and Topics
| Section | Topics within the section
 |
| --- | --- |
| X86/Arm assembler introduction | 1. • Basic assembler: registers, operations
2. • x86 ABI reference
3. • Context switching
4. • CPU security rings
 |
| Linux Kernel introduction | 1. • Kernel usage
2. • Supported HW
3. • Building the kernel
 |
| Booting the Kernel | 1. • Boot Sequence
2. • Device Tree
3. • U-boot
4. • initrd/initramfs
 |
| Kernel Modules | 1. • Linux device and driver m​odel
2. • Virtual Filesystems
 |
| Memory management | 1. • Physical Memory
2. • Virtual Memory
3. • Memory Allocation
 |
| Threads, processes and scheduling | 1. • Thread
2. • Processes
3. • Timers
 |
| Concurrent access to resources | 1. • Mutexes
2. • Spin locks
3. • RW-locks
 |
| Kernel debugging | 1. • Debugging techniques
2. • DebugFS
3. • Other methods overview (J-Tag etc).
 |


Intended Learning Outcomes (ILOs)
---------------------------------


### What is the main purpose of this course?


The main purpose of this course is to give the students advanced knowledge of how Linux operation system boots, works and what parts it is consists of.



### ILOs defined at three levels


#### Level 1: What concepts should a student know/remember/explain?


By the end of the course, the students should be able to ...



* • Principles of Operating Systems.
* • Principles of bootloaders (first- /second- stage).
* • Linux booting principles.


#### Level 2: What basic practical skills should a student be able to perform?


By the end of the course, the students should be able to ...



* • Memory management in Kernel and userspace.
* • Linux kernel subsustems.
* • Concurrent access to resources.
* • HW devices interaction in Linux.
* • Interrupt and multithreading execution.
* • Real- and virtual- filesystems interaction.


#### Level 3: What complex comprehensive skills should a student be able to apply in real-life scenarios?


By the end of the course, the students should be able to ...



* • Kernel drivers design skills.
* • Linux Kernel contribution and advanced GIT knowledge.
* • C language low-level Kernel programming.
* • C/C++ language system programming.
* • POSIX API usage.
* • Kernel and userspace debugging (including KGDB/GDB).
* • x86/ARM assembly programming.


Grading
-------


### Course grading range





| Grade | Range | Description of performance
 |
| --- | --- | --- |
| A. Excellent | 90-100 | -
 |
| B. Good | 75-89 | -
 |
| C. Satisfactory | 60-74 | -
 |
| D. Poor | 0-59 | -
 |


### Course activities and grading breakdown





| Activity Type | Percentage of the overall course grade
 |
| --- | --- |
| Labs/seminar classes | 40
 |
| Interim performance assessment | 10
 |
| Exams | 50
 |


### Recommendations for students on how to succeed in the course


Resources, literature and reference materials
---------------------------------------------


### Open access resources


* • Writing Kernel Module: i2c -
* • Fundamental Linux Kernel programming by Krishenko V.A., Rayzanova N.U. - /
* • Linux Operating System by Kuryachiy G.V., Malinskiy K.A. -
* • Systemd after 10 years, historical and techical review, -
* • Evolution of Linux Kernel by Novikov E.M., -
* • Online resources shared by instructor


### Closed access resources


### Software and tools used within the course


Teaching Methodology: Methods, techniques, & activities
=======================================================


Activities and Teaching Methods
-------------------------------




Activities within each section
| Learning Activities | Section 1 | Section 2 | Section 3 | Section 4 | Section 5 | Section 6 | Section 7 | Section 8
 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Development of individual parts of software product code | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
 |
| Homework and group projects | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1
 |
| Midterm evaluation | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0
 |
| Testing (written or computer based) | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
 |
| Discussions | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
 |


Formative Assessment and Course Activities
------------------------------------------


### Ongoing performance assessment


#### Section 1





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | 1. ARM architecture is faster than x86, itn’s it? | 1
 |
| Question | 2. Why does antivirus software works in RING0? | 1
 |
| Question | 3. What is the main purpose of having interrupts? | 1
 |
| Question | 4. How-to debug anything inside interrupt context? | 1
 |
| Question | 1. Show the difference in x86 and ARM CPU registers. | 0
 |
| Question | 2. Create `basic` atomic operations for ARM in x86 (and vice versa). | 0
 |
| Question | 3. Implement simple context switching without threads. | 0
 |


#### Section 2





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | 1. Monolithic kernel vs Micro-kernel. What is faster and why? | 1
 |
| Question | 2. How Linux works on HW without IOMMU? | 1
 |
| Question | 3. Tools required for building Linux Kernel. | 1
 |
| Question | 4. Name few operations systems bases on Linux and name the difference. | 1
 |
| Question | 1. Contributing to Open Source software and Kernel. What is the difference? | 0
 |
| Question | 2. Git usage: commits, email-patches. | 0
 |
| Question | 3. Git usage: rewriting history. | 0
 |
| Question | 4. Building Linux Kernel for your own PC. | 0
 |
| Question | 5. Running new Kernel on your machine. | 0
 |
| Question | 6. Kernel config file location and editing. | 0
 |


#### Section 3





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | 1. What is the difference between BIOS and UEFI? What we prefer in nowadays? | 1
 |
| Question | 2. What is the usage for secure boot? What requirements should be met for this? | 1
 |
| Question | 3. Why in x86 we do not have device tree? And why is it required for ARM platforms? | 1
 |
| Question | 4. What is the purpose of having initramfs? Can we skip that stage? | 1
 |
| Question | 1. Build U-boot | 0
 |
| Question | 2. Rebuilding initramfs | 0
 |
| Question | 3. Changing boot order of your PC. Creating simple systemd service. | 0
 |


#### Section 4





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | 1. How kernel module can be compiled and used inside or outside Linux Kernel Image? | 1
 |
| Question | 2. What is the purpose of System.map file for correct Linux Kernel functionality? | 1
 |
| Question | 3. What is the real requirement to have virtual filesystems in Linux Kernel? | 1
 |
| Question | 4. Name few real and virtual filesystems. Briefly describe usage in real life. | 1
 |
| Question | 1. Develop and deploy simple Kernel Module outside kernel image. Dynamic Loading. | 0
 |
| Question | 2. Develop and deploy simple Kernel Module inside kernel image. | 0
 |
| Question | 3. SysFS/ DebugFS / ProcFS/ TmpFS usage | 0
 |


#### Section 5





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | 1. Why do we need virtual memory? | 1
 |
| Question | 2. Why does Linux Kernel maps itself to every process address space? | 1
 |
| Question | 3. How does page fault handler work? | 1
 |
| Question | 4. What is segmentation fault and how it handles in Linux Kernel? | 1
 |
| Question | 1. Create simple allocator (myalloc/myfree). | 0
 |
| Question | 2. Create benchmark for simple allocator. | 0
 |


#### Section 6





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | 1. What is the difference between thread and process? | 1
 |
| Question | 2. Can process exist without any threads? | 1
 |
| Question | 3. What scheduling methods does Linux Kernel has? | 1
 |
| Question | 4. What make `realtime` OS really realtime? | 1
 |
| Question | 5. What is the difference between cooperative and preemptive multitasking? | 1
 |
| Question | 1. Implement your own threads inside app. | 0
 |
| Question | 2. Implement simple scheduler for your threading app. | 0
 |
| Question | 3. Implement timer for your app without using `real` timers. | 0
 |


#### Section 7





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | 1. Why do we need locking structures? | 1
 |
| Question | 2. Where is mutex preferred on spinlock? | 1
 |
| Question | 3. Where is spinlock preferred on mutex? | 1
 |
| Question | 4. Can we just write locking-free code? | 1
 |
| Question | 5. What is deadlock and how it could be handled? | 1
 |
| Question | 1. Implement simple locking structures. | 0
 |
| Question | 2. Implement Wait-die lock. | 0
 |


#### Section 8





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | 1. Name and briefly describe kernel-debugging techniques. | 1
 |
| Question | 2. What debug levels for printk do you know and what is their usage? | 1
 |
| Question | 3. What other methods of Kernel debugging techniques do you know? | 1
 |
| Question | 4. Why can’t we use regular GDB to debug Linux Kernel? | 1
 |
| Question | 1. Usage of DebugFS for basic debugging | 0
 |
| Question | 2. Usage of printk and debug levels. | 0
 |
| Question | 3. KGDB usage for Kernel debugging. | 0
 |


### Final assessment


**Section 1**



1. 1. Describe basic CPU registers and their purpose.
2. 2. Describe x86 ABI.
3. 3. What is context switching and how does it work?
4. 4. Name all CPU security rings and describe security levels.
5. 5. Interrupts. Interrupt handler.


**Section 2**



1. 1. Briefly describe modern OS architecture. (for ex. Linux)
2. 2. Describe supported HW by Linux Kernel.
3. 3. Describe contribution process to Linux Kernel.


**Section 3**



1. 1. Name popular bootloaders and briefly describe the difference.
2. 2. Describe all boot sequence starting from pushing START button.
3. 3. Describe in details the role of initrd/initramfs in booting process.
4. 4. First userspace process. Describe how it works and why do we need SystemV/system?


**Section 4**



1. 1. Describe Linux device and driver model
2. 2. Real- and Virtual- filesystems. Describe in details.
3. 3. Name other Linux Kernel subsystems and their usage.


**Section 5**



1. 1. Describe how virtual memory maps on physical memory.
2. 2. Describe in details how TLB works. How TLB increases memory operations?
3. 3. Describe structure of page table, its location and management from OS.
4. 4. Describe memory allocation techniques. Describe one of them in details.


**Section 6**



1. 1. Describe how threading works.
2. 2. Describe pthread API usage.
3. 3. Describe difference between monotomic and realtime clocks.
4. 4. Describe scheduling strategies. Make a suggestion, which one is preferred for different situations.
5. 5. Describe difference in memory management between threads and processes.


**Section 7**



1. 1. Describe mutex internals.
2. 2. Describe spin lock internals.
3. 3. Describe deadlock problem and how it could be handled.
4. 4. Compare different locking methods and make conclusion of which is faster and why.
5. 5. Deeply describe wait-die locks.


**Section 8**



1. 1. Explain usage of debugFS in modern kernels.
2. 2. Describe main kernel debugging techniques.


### The retake exam


**Section 1**


**Section 2**


**Section 3**


**Section 4**


**Section 5**


**Section 6**


**Section 7**


**Section 8**











