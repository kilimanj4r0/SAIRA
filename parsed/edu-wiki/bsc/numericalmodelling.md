






BSc:NumericalModelling
======================






Contents
--------


* [1 Numerical Modelling](#Numerical_Modelling)
	+ [1.1 Course characteristics](#Course_characteristics)
		- [1.1.1 Key concepts of the class](#Key_concepts_of_the_class)
		- [1.1.2 What is the purpose of this course?](#What_is_the_purpose_of_this_course.3F)
		- [1.1.3 Course Objectives Based on Bloom’s Taxonomy](#Course_Objectives_Based_on_Bloom.E2.80.99s_Taxonomy)
		- [1.1.4 - What should a student remember at the end of the course?](#-_What_should_a_student_remember_at_the_end_of_the_course.3F)
		- [1.1.5 - What should a student be able to understand at the end of the course?](#-_What_should_a_student_be_able_to_understand_at_the_end_of_the_course.3F)
		- [1.1.6 - What should a student be able to apply at the end of the course?](#-_What_should_a_student_be_able_to_apply_at_the_end_of_the_course.3F)
		- [1.1.7 Course evaluation](#Course_evaluation)
		- [1.1.8 Grades range](#Grades_range)
		- [1.1.9 Resources and reference material](#Resources_and_reference_material)
			* [1.1.9.1 Textbooks:](#Textbooks:)
			* [1.1.9.2 Reference material:](#Reference_material:)
	+ [1.2 Course Sections](#Course_Sections)
		- [1.2.1 Section 1](#Section_1)
			* [1.2.1.1 Section title:](#Section_title:)
		- [1.2.2 Topics covered in this section:](#Topics_covered_in_this_section:)
		- [1.2.3 What forms of evaluation were used to test students’ performance in this section?](#What_forms_of_evaluation_were_used_to_test_students.E2.80.99_performance_in_this_section.3F)
		- [1.2.4 Typical questions for ongoing performance evaluation within this section](#Typical_questions_for_ongoing_performance_evaluation_within_this_section)
		- [1.2.5 Typical questions for seminar classes (labs) within this section](#Typical_questions_for_seminar_classes_.28labs.29_within_this_section)
		- [1.2.6 Test tasks for final assessment in this section](#Test_tasks_for_final_assessment_in_this_section)
		- [1.2.7 Section 2](#Section_2)
			* [1.2.7.1 Section title:](#Section_title:_2)
		- [1.2.8 Topics covered in this section:](#Topics_covered_in_this_section:_2)
		- [1.2.9 What forms of evaluation were used to test students’ performance in this section?](#What_forms_of_evaluation_were_used_to_test_students.E2.80.99_performance_in_this_section.3F_2)
		- [1.2.10 Typical questions for ongoing performance evaluation within this section](#Typical_questions_for_ongoing_performance_evaluation_within_this_section_2)
		- [1.2.11 Typical questions for seminar classes (labs) within this section](#Typical_questions_for_seminar_classes_.28labs.29_within_this_section_2)
		- [1.2.12 Test tasks for final assessment in this section](#Test_tasks_for_final_assessment_in_this_section_2)
	+ [1.3 Exams and retake planning](#Exams_and_retake_planning)
		- [1.3.1 Exam](#Exam)
		- [1.3.2 Retake 1](#Retake_1)
		- [1.3.3 Retake 2](#Retake_2)



Numerical Modelling
===================


* **Course name:** Numerical Modelling
* **Course number:** XYZ
* **Subject area:** Math


Course characteristics
----------------------


### Key concepts of the class


* An understanding of the basic "canon" of numerical algorithms and numerical methods relevant to computing given task


### What is the purpose of this course?


This course answer on the next questions. To what problems does an algorithm or method apply? How does the method work? How does the method compare to alternatives (in terms of appropriate computational metrics)? What can go wrong? What are the sources of error and uncertainty?



### Course Objectives Based on Bloom’s Taxonomy


### - What should a student remember at the end of the course?


* Understand key principles involved in numerical solution of typical mathematical problems.
* Become familiar with numerical differentiation and integration.
* Solve systems of non/linear algebraic equations numerically by different ways.
* Become familiar with methods of interpolation and regression.
* Get hands-on experience with numerical solving system of nonlinear differential equations.


### - What should a student be able to understand at the end of the course?


* Key principles involved in numerical solution of typical mathematical problems.
* How to apply numerical differentiation and integration.
* How to solve systems of non/linear algebraic equations numerically by different ways.
* How to apply methods of interpolation and regression.
* How to make numerical solving system of nonlinear differential equations.


### - What should a student be able to apply at the end of the course?


* Numerical solution of typical mathematical problems
* Make nonlinear regression and interpolation
* Make numerical differentiation and integration
* Numerical solution systems of non/linear algebraic equations
* Numerical solving system of nonlinear differential equations


### Course evaluation




Course grade breakdown
|  |  | **Proposed points** |
| --- | --- | --- |
| Labs/seminar classes
 | 20
 | 30
 |
| Interim performance assessment
 | 30
 | 30
 |
| Exams
 | 50
 | 50
 |


### Grades range




Course grading range
|  |  | **Proposed range** |
| --- | --- | --- |
| A. Excellent
 | 90-100
 | 85-100
 |
| B. Good
 | 75-89
 | 65-84
 |
| C. Satisfactory
 | 60-74
 | 50-64
 |
| D. Poor
 | 0-59
 | 0-49
 |


### Resources and reference material


#### Textbooks:


* Gilbert Strang. Computational Science and Engineering. Wellesley, MA: Wellesley-Cambridge Press, 2007. 727 Pg. ISBN: 9780961408817.
* I.B. Petrov, A.I. Lobanov. Lectures in Computational Mathematics. M.: Internet University of Information Technology, 2006. 523 c. ISBN: 5-94774-542-9.


#### Reference material:


* Jaan Kiusalaas. Numerical Methods in Engineering with Python. Cambridge University Press, 2005. 433 Pg. ISBN: 978-0-521-85287-6.


Course Sections
---------------


The main sections of the course and approximate hour distribution between them is as follows:





Course Sections
| **Section** | **Section Title** | **Lectures** | **Seminars** | **Self-study** | **Knowledge** |
| **Number** |  | **(hours)** | **(labs)** |  | **evaluation** |
| 1
 | Numerical differentiation and integration, functions interpolation, solution of system of linear algebraic equations.
 | 14
 | 14
 | 28
 | 2
 |
| 2
 | Solution of nonlinear algebraic equations and systems. Solving of ODEs and PDEs. Discrete Fourier Series.
 | 12
 | 12
 | 24
 | 2
 |
| Final examination
 |  |  |  |  | 2
 |


### Section 1


#### Section title:


Numerical differentiation and integration, functions interpolation, solution of system of linear algebraic equations



### Topics covered in this section:


* Key concerns of numerical computations. Accuracy of floating-point arithmetic.
* Numerical differentiation. Method of undetermined coefficients.
* Interpolation of functions. Splines.
* Numerical integration. Quadrature formulas.
* Solution of system of linear algebraic equations.


### What forms of evaluation were used to test students’ performance in this section?



|a|c| & **Yes/No**  

Development of individual parts of software product code & 1  

Homework and group projects & 1  

Midterm evaluation & 1  

Testing (written or computer based) & 1  

Reports & 0  

Essays & 0  

Oral polls & 0  

Discussions & 1  



  





### Typical questions for ongoing performance evaluation within this section


1. How to perform numerical differentiation by the method of undetermined coefficients?
2. How to perform interpolation of function by using splines?
3. How to perform numerical integration by using quadrature formulas?
4. How to solve a system of linear algebraic equations by using iteration methods?
5. How to solve a system of linear algebraic equations by using variation methods?


### Typical questions for seminar classes (labs) within this section


1. To make numerical differentiation by the method of undetermined coefficients.
2. To make function interpolation by using splines.
3. To make numerical integration by using quadrature formulas.
4. To Solve a system of linear algebraic equations by using iteration methods?
5. To solve a system of linear algebraic equations by using variation methods?


### Test tasks for final assessment in this section


1. You are requested to compute the integral of a black box function. The function would be supplied to you at the compile time in the form of a header file 



b
l
a
c
k
b
o
x
.
h


{\textstyle blackbox.h}

![{\textstyle blackbox.h}](https://wikimedia.org/api/rest_v1/media/math/render/svg/bc214d34820b8ed755b9eeac596f60a065b91fb9). At the very beginning of your program you should read single integer 



n


{\textstyle n}

![{\textstyle n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cc6e1f880981346a604257ebcacdef24c0aca2d6) from the standard input call the function 



b
l
a
c
k
b
o
x
−
i
n
i
t
(
n
)


{\textstyle blackbox-init(n)}

![{\textstyle blackbox-init(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5da4274de7b5b05da48d2297c7ced372b00a8e98). 



b
l
a
c
k
b
o
x
−
i
n
i
t


{\textstyle blackbox-init}

![{\textstyle blackbox-init}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b3ca595eadcbe04f8318dfdb9ef96581f3b809dd) should only be called once. All other functions should only be called after 



b
l
a
c
k
b
o
x
−
i
n
i
t


{\textstyle blackbox-init}

![{\textstyle blackbox-init}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b3ca595eadcbe04f8318dfdb9ef96581f3b809dd). Calling 



b
l
a
c
k
b
o

x

i


n
i
t


{\textstyle blackbox\_{i}nit}

![{\textstyle blackbox_{i}nit}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0fcf2215e6b99e33726e06e7f6c303aedb27f8c8) with argument different from the one supplied via standard input leads to undefined behaviour.


When you want to get the value of the function at point 



x


{\textstyle x}

![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781) you should call 



b
l
a
c
k
b
o
x
(
x
)


{\textstyle blackbox(x)}

![{\textstyle blackbox(x)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/748e934a36364010528ce8538a96dedc5f83789f). This function is guaranteed to be thread-safe. 



x


{\textstyle x}

![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781) should be in range [-1; 1].


If you want to get the maximum absolute value of the 



k
−
t
h


{\textstyle k-th}

![{\textstyle k-th}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3321573144779e5db079a4f0c3551196e7559103) derivative of the black box function on the integration interval, you should call 



b
l
a
c
k
b
o
x
−
d
f
(
k
)


{\textstyle blackbox-df(k)}

![{\textstyle blackbox-df(k)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/79dbac96ea34910f40cdea0f69c0b27ec5073839). The 



k


{\textstyle k}

![{\textstyle k}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0d5595fc0c47452f8fc2aa6e29c3611f047714b0) should be integer from 1 to 6.


To check if the black box function is oscillating you should call 



b
l
a
c
k
b
o
x
−
p
e
r
i
o
d
(
)


{\textstyle blackbox-period()}

![{\textstyle blackbox-period()}](https://wikimedia.org/api/rest_v1/media/math/render/svg/890241a4393cae886d9511eed447621a837eb54b).


The returned value would be the period length if the function is oscillating, and 0 otherwise.


The required absolute precision is 




10

−


9


{\textstyle 10^{-}9}

![{\textstyle 10^{-}9}](https://wikimedia.org/api/rest_v1/media/math/render/svg/bb38ffe9ec7f4816fef052f8d56abb471e682981). The truncated 



b
l
a
c
k
b
o
x
.
h


{\textstyle blackbox.h}

![{\textstyle blackbox.h}](https://wikimedia.org/api/rest_v1/media/math/render/svg/bc214d34820b8ed755b9eeac596f60a065b91fb9) file (implementing only one of possible blackbox functions) and an example (suboptimal) solution 



s
o
l
u
t
i
o
n
.
c
p
p


{\textstyle solution.cpp}

![{\textstyle solution.cpp}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8d9ceb3f356ccb3e38eb2c123b655c3c2c6bc1c4) are available to you on the “Files” tab in PCMS.


You should only submit your 



s
o
l
u
t
i
o
n
.
c

/

s
o
l
u
t
i
o
n
.
c
p
p


{\textstyle solution.c/solution.cpp}

![{\textstyle solution.c/solution.cpp}](https://wikimedia.org/api/rest_v1/media/math/render/svg/94a369063ed3a5fc42041bd897af9cf15f4427f6) file. The appropriate 



b
l
a
c
k
b
o
x
.
h


{\textstyle blackbox.h}

![{\textstyle blackbox.h}](https://wikimedia.org/api/rest_v1/media/math/render/svg/bc214d34820b8ed755b9eeac596f60a065b91fb9) will be supplied by the testing system.


You should not try to reverse-engineer the black box and/or interact with it in any way except through the four functions listed above.
2. The task is simple: you have to fit a set of points with a 9-degree polynomial






y
=

a

9



x

9


+

a

8



x

8


+
.
.
.
+

a

1


x
+

a

0




{\textstyle y=a\_{9}x^{9}+a\_{8}x^{8}+...+a\_{1}x+a\_{0}}

![{\textstyle y=a_{9}x^{9}+a_{8}x^{8}+...+a_{1}x+a_{0}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/28bd220b09302f11f4d4523e006c53cae32ded16).


Your program receives the following stream of commands:


	* ADD 
	
	
	
	x
	
	
	{\textstyle x}
	
	![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781) 
	
	
	
	y
	
	
	{\textstyle y}
	
	![{\textstyle y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/db9936ddb2761b76fa640fb275cb5d1fa4d6fa23) Read values 
	
	
	
	x
	
	
	{\textstyle x}
	
	![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781) and 
	
	
	
	y
	
	
	{\textstyle y}
	
	![{\textstyle y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/db9936ddb2761b76fa640fb275cb5d1fa4d6fa23).
	* FIT Print the coefficients for a polynomial fitted through all the points read since the beginning of the program. You will have no more than 13 FIT commands in each test.
	* END Print the coefficients for a polynomial fitted through all the points read since the beginning of the program, and quit.You will get no more than 107 commands before END.
3. The task is simple: you have to solve a system of linear algebraic equations (SLAE) 



A
x
=
b


{\textstyle Ax=b}

![{\textstyle Ax=b}](https://wikimedia.org/api/rest_v1/media/math/render/svg/18892a5ddb5ea2e30e8a4a9488b35d67a3fdbf6d) with residual no more than 




10

−


9


{\textstyle 10^{-}9}

![{\textstyle 10^{-}9}](https://wikimedia.org/api/rest_v1/media/math/render/svg/bb38ffe9ec7f4816fef052f8d56abb471e682981).


And the matrix 



A


{\textstyle A}

![{\textstyle A}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a118c6ad00742b3f5dccd2f0e74b5e369df6fd31) is very nice: non-singular, symmetric and strictly diagonally dominant. A piece of cake, you might think. The catch: you do not have 



A


{\textstyle A}

![{\textstyle A}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a118c6ad00742b3f5dccd2f0e74b5e369df6fd31) in any explicit form.


You can only get the result of its multiplication with the vector.


You have a number of the blackbox functions through which you work with the SLAE:


	* void 
	
	
	
	b
	l
	a
	c
	k
	b
	o
	x
	−
	i
	n
	i
	t
	(
	)
	
	
	{\textstyle blackbox-init()}
	
	![{\textstyle blackbox-init()}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0477b1341596162853aa16a18282e118ed5061d7) – initializes the internal blackbox data structures. Should be called in the very beginning of the program! No other blackbox function should be called before it, and no reading from the 
	
	
	
	s
	t
	d
	i
	n
	
	
	{\textstyle stdin}
	
	![{\textstyle stdin}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0f6339301fbc54a4f01a257566878bf08667872b) shall be made (or at least, as they say, “be kind, rewind”).
	* int 
	
	
	
	b
	l
	a
	c
	k
	b
	o
	x
	−
	s
	i
	z
	e
	(
	)
	
	
	{\textstyle blackbox-size()}
	
	![{\textstyle blackbox-size()}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a4285c43309168e889b1900d21b1c937539572b1) – returns the number of equations (which is equal to the number of unknowns) of the system. The number of equations lies between 10 and 10000 (inclusive).
	* void 
	
	
	
	b
	l
	a
	c
	k
	b
	o
	x
	−
	m
	u
	l
	t
	
	
	{\textstyle blackbox-mult}
	
	![{\textstyle blackbox-mult}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1085ed1979d1dfc4da3be96e4114501a62954502) (const double 
	
	
	
	∗
	x
	
	
	{\textstyle \*x}
	
	![{\textstyle *x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e61b054ceed7e5277d5afa7d0f5af38f4ad1385a), double 
	
	
	
	∗
	o
	u
	t
	
	
	{\textstyle \*out}
	
	![{\textstyle *out}](https://wikimedia.org/api/rest_v1/media/math/render/svg/afb27fe7acf1e82904277d5018dfe79494fb9023)) – compute the product of 
	
	
	
	A
	
	
	{\textstyle A}
	
	![{\textstyle A}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a118c6ad00742b3f5dccd2f0e74b5e369df6fd31) and vector 
	
	
	
	x
	
	
	{\textstyle x}
	
	![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781), write the results to out. The pointers 
	
	
	
	x
	
	
	{\textstyle x}
	
	![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781) and out should point to different chunks of memory of size at least 
	
	
	
	b
	l
	a
	c
	k
	b
	o
	x
	−
	s
	i
	z
	e
	(
	)
	∗
	s
	i
	z
	e
	o
	f
	(
	d
	o
	u
	b
	l
	e
	)
	
	
	{\textstyle blackbox-size()\*sizeof(double)}
	
	![{\textstyle blackbox-size()*sizeof(double)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5d0e1afff85d10975800f6a72114273faa922b92) bytes each.
	* void 
	
	
	
	b
	l
	a
	c
	k
	b
	o
	x
	−
	r
	h
	s
	(
	d
	o
	u
	b
	l
	e
	∗
	b
	)
	
	
	{\textstyle blackbox-rhs(double\*b)}
	
	![{\textstyle blackbox-rhs(double*b)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/eb7690a661cfb5fd2efafd18ff6fcbadf80fa78b) – write the right-hand side of the SLAE (i.e., vector 
	
	
	
	b
	
	
	{\textstyle b}
	
	![{\textstyle b}](https://wikimedia.org/api/rest_v1/media/math/render/svg/73a780b69dfc55238880ef18a134dc65260877e2)) to the array 
	
	
	
	b
	
	
	{\textstyle b}
	
	![{\textstyle b}](https://wikimedia.org/api/rest_v1/media/math/render/svg/73a780b69dfc55238880ef18a134dc65260877e2). The pointer 
	
	
	
	b
	
	
	{\textstyle b}
	
	![{\textstyle b}](https://wikimedia.org/api/rest_v1/media/math/render/svg/73a780b69dfc55238880ef18a134dc65260877e2) should point to the chunk if memory of size at least 
	
	
	
	b
	l
	a
	c
	k
	b
	o
	x
	−
	s
	i
	z
	e
	(
	)
	∗
	s
	i
	z
	e
	o
	f
	(
	d
	o
	u
	b
	l
	e
	)
	
	
	{\textstyle blackbox-size()\*sizeof(double)}
	
	![{\textstyle blackbox-size()*sizeof(double)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5d0e1afff85d10975800f6a72114273faa922b92) bytes.
	* void 
	
	
	
	b
	l
	a
	c
	k
	b
	o
	x
	−
	s
	u
	b
	m
	i
	t
	(
	d
	o
	u
	b
	l
	e
	∗
	s
	o
	l
	u
	t
	i
	o
	n
	)
	
	
	{\textstyle blackbox-submit(double\*solution)}
	
	![{\textstyle blackbox-submit(double*solution)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e18ee608df1dff4828047ed8be6b109e23a40e15) – write the result of the program. The array solution should contain the solution to the SLAE: 
	
	
	
	b
	l
	a
	c
	k
	b
	o
	x
	−
	s
	i
	z
	e
	(
	)
	
	
	{\textstyle blackbox-size()}
	
	![{\textstyle blackbox-size()}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a4285c43309168e889b1900d21b1c937539572b1) values of type double. This should the last function to be called by your program (besides return 0;).


### Section 2


#### Section title:


Solution of nonlinear algebraic equations and systems. Solving of ODEs and PDEs. Discrete Fourier Series.



### Topics covered in this section:


* Numerical solution of nonlinear algebraic equations and systems.
* Basic concepts of the theory of difference schemes. Numerical methods for solving of initial value problem for ordinary differential equations (ODEs).
* Numerical methods for solving of boundary value problems for ODEs.
* Discrete Fourier Series. Numerical solution of second-order ODEs by Discrete Fourier Series. Numerical solution of the partial differential equations (PDEs) by Discrete Fourier Series.
* Variable-directions method. Numerical solution of the PDEs by finite difference methods.


### What forms of evaluation were used to test students’ performance in this section?



|a|c| & **Yes/No**  

Development of individual parts of software product code & 1  

Homework and group projects & 1  

Midterm evaluation & 1  

Testing (written or computer based) & 1  

Reports & 0  

Essays & 0  

Oral polls & 0  

Discussions & 1  



  





### Typical questions for ongoing performance evaluation within this section


1. How to perform numerical solution of nonlinear algebraic equations and systems.
2. How to perform numerical solution of initial value problem for ordinary differential equations (ODEs).
3. How to perform numerical solution of boundary value problems for ODEs.
4. How to perform numerical solution of ODEs and PDEs by Discrete Fourier Series.
5. How to perform numerical solution of the PDEs by finite difference methods.


### Typical questions for seminar classes (labs) within this section


1. To make numerical solution of nonlinear algebraic equations and systems.
2. To make numerical solution of initial value problem for ordinary differential equations (ODEs).
3. To make numerical solution of boundary value problems for ODEs.
4. To make numerical solution of ODEs and PDEs by Discrete Fourier Series.
5. To make numerical solution of the PDEs by finite difference methods.


### Test tasks for final assessment in this section


1. You have to build software for a new GPS/GLONASS receiver. The satellite navigation works as follows (of course, this is a rather simplified description of a real-world situation). There are 



N


{\textstyle N}

![{\textstyle N}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0d21d55fc102ec49600d3d5522a59ae4561acc22) < 30 satellites. Every satellite broadcasts its position (




x

i


;

y

i


;

z

i




{\textstyle x\_{i};y\_{i};z\_{i}}

![{\textstyle x_{i};y_{i};z_{i}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/21642e2911fbecbc9fa31a9828cda8163ea2c106)) and high-precision synchronized time 




t

i




{\textstyle t\_{i}}

![{\textstyle t_{i}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9cd7332b2fc29d70f9f69f1f721cdf6996f6ee38). These signals take time to reach the receiver (e.g., the one that’s in your smartphone). If the receiver has position 



x


{\textstyle x}

![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781); 



y


{\textstyle y}

![{\textstyle y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/db9936ddb2761b76fa640fb275cb5d1fa4d6fa23); 



z


{\textstyle z}

![{\textstyle z}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7a33e37010e3acdeeb80fdb95df9bfe411fd79e6), and receives the signal at time 



t


{\textstyle t}

![{\textstyle t}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b2bc926f90178739fccd01a96c6fa778ab3535d6), the following equation (called “Navigation equation”) holds true (For simplicity, we choose the speed of light 



c


{\textstyle c}

![{\textstyle c}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7d411ca19645ddd4fff0704de95ec770681093bb) = 1):






(
x
−

x

i



)

2


+
(
y
−

y

i



)

2


+
(
z
−

z

i



)

2


=
(
t
−

t

i



)

2




{\textstyle (x-x\_{i})^{2}+(y-y\_{i})^{2}+(z-z\_{i})^{2}=(t-t\_{i})^{2}}

![{\textstyle (x-x_{i})^{2}+(y-y_{i})^{2}+(z-z_{i})^{2}=(t-t_{i})^{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d424c43572353a6149b6291cc1b0d8b88659d815)


As we can see, we have four unknowns (the position of the receiver 



x


{\textstyle x}

![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781); 



y


{\textstyle y}

![{\textstyle y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/db9936ddb2761b76fa640fb275cb5d1fa4d6fa23); 



z


{\textstyle z}

![{\textstyle z}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7a33e37010e3acdeeb80fdb95df9bfe411fd79e6) and the precise time 



t


{\textstyle t}

![{\textstyle t}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b2bc926f90178739fccd01a96c6fa778ab3535d6) when it received the signal). So, we need at least 



N


{\textstyle N}

![{\textstyle N}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0d21d55fc102ec49600d3d5522a59ae4561acc22) = 4 satellites to get the location of the receiver (“fix”). The system of exactly four navigational equations might, in general, have multiple solutions. But usually, more than 



N


{\textstyle N}

![{\textstyle N}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0d21d55fc102ec49600d3d5522a59ae4561acc22) > 4 satellites are visible, and we have an overdetermined system of nonlinear equations (due to noise, the equations can not be satisfied exactly). In this case, our goal is to minimize the sum of squares of residuals:






S
u

m

i


(
(
x
−

x

i



)

2


+
(
y
−

y

i



)

2


+
(
z
−

z

i



)

2


−
(
t
−

t

i



)

2


)

→


m
i
n


{\textstyle Sum\_{i}((x-x\_{i})^{2}+(y-y\_{i})^{2}+(z-z\_{i})^{2}-(t-t\_{i})^{2})\xrightarrow {} min}

![{\textstyle Sum_{i}((x-x_{i})^{2}+(y-y_{i})^{2}+(z-z_{i})^{2}-(t-t_{i})^{2})\xrightarrow {} min}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e19d6ecb0c666b5907e4ba4a68677c11e9c41cfa).


You program should continuously read data from a virtual GPS receiver and print the position in each moment until the signal is lost. The number of satellites (and their order) can change. The initial position is unknown, but the position between successive readings does not change too much. The required accuracy is given by






S
u

m

i


(
(
x
−

x

i



)

2


+
(
y
−

y

i



)

2


+
(
z
−

z

i



)

2


−
(
t
−

t

i



)

2


)
<

10

−
6




{\textstyle Sum\_{i}((x-x\_{i})^{2}+(y-y\_{i})^{2}+(z-z\_{i})^{2}-(t-t\_{i})^{2})<10^{-6}}

![{\textstyle Sum_{i}((x-x_{i})^{2}+(y-y_{i})^{2}+(z-z_{i})^{2}-(t-t_{i})^{2})<10^{-6}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/921e56ff05b67775128fb8816d73ee551f803ea4).


It is guaranteed that such solution exists. The coordinates 



x


{\textstyle x}

![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781); 



y


{\textstyle y}

![{\textstyle y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/db9936ddb2761b76fa640fb275cb5d1fa4d6fa23); 



z


{\textstyle z}

![{\textstyle z}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7a33e37010e3acdeeb80fdb95df9bfe411fd79e6) are in range [-10; 10], the time 



t


{\textstyle t}

![{\textstyle t}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b2bc926f90178739fccd01a96c6fa778ab3535d6) is in range [-1000; 1000].


The number of readings is guaranteed not to exceed 




10

5




{\textstyle 10^{5}}

![{\textstyle 10^{5}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/fa295cf101b8cf8e674e5fae629bf0d861345394).
2. You have to build a simulation software for a new chemical reactor. Your program is given a list of chemical reactions and initial concentrations of all components. You should output the concentrations after time 



t


{\textstyle t}

![{\textstyle t}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b2bc926f90178739fccd01a96c6fa778ab3535d6).


In first-order reactions, only one molecule is necessary for the reaction, and the reaction rate is proportional to the concentration of this reagent:






A

→


k

1





n

1



B

1


+

n

2



B

2


+
.
.
.
+

n

I



B

I




{\textstyle A\xrightarrow {k\_{1}} n\_{1}B\_{1}+n\_{2}B\_{2}+...+n\_{I}B\_{I}}

![{\textstyle A\xrightarrow {k_{1}} n_{1}B_{1}+n_{2}B_{2}+...+n_{I}B_{I}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/67e691753838d3f478142d270d05d259de731328).


For this reaction, we can write down the following system of ODEs:






d
[
A
]

/

d
t
=
−

k

1


[
A
]


{\textstyle d[A]/dt=-k\_{1}[A]}

![{\textstyle d[A]/dt=-k_{1}[A]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9c34a1ec7a9b83456c10afe363dedebda6fdd06a)






d
[

B

i


]

/

d
t
=

n

i



k

1


[
A
]


{\textstyle d[B\_{i}]/dt=n\_{i}k\_{1}[A]}

![{\textstyle d[B_{i}]/dt=n_{i}k_{1}[A]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1842b0de7c722ea4d528d340073f1d88bbe32eb4), 



i
=
1
,
.
.
.
,
I


{\textstyle i=1,...,I}

![{\textstyle i=1,...,I}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7293273f9bd64c3c4f26016ba6dd0da2ea708b3d).


Here, 



[
A
]


{\textstyle [A]}

![{\textstyle [A]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/efc7c42d7e9f789e2b3384a4f718faddeb0f2119) is the concentration of molecule 



A


{\textstyle A}

![{\textstyle A}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a118c6ad00742b3f5dccd2f0e74b5e369df6fd31), 



[

B

i


]


{\textstyle [B\_{i}]}

![{\textstyle [B_{i}]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b93529c326fe80f88113659fe061fea392c8aacb) is the concentration of 




B

i




{\textstyle B\_{i}}

![{\textstyle B_{i}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7aa989ce5aa4efcf8bf388bc5ac1866445718894) molecules, and 




k

1




{\textstyle k\_{1}}

![{\textstyle k_{1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d6f9b2fbaa7850ed8769501088a6825203e38182) is the reaction rate constant.


In second order reactions, two molecules are necessary for the reaction to proceed:






A
+
C

→


k

2





n

1



B

1


+

n

2



B

2


+
.
.
.
+

n

I



B

I




{\textstyle A+C\xrightarrow {k\_{2}} n\_{1}B\_{1}+n\_{2}B\_{2}+...+n\_{I}B\_{I}}

![{\textstyle A+C\xrightarrow {k_{2}} n_{1}B_{1}+n_{2}B_{2}+...+n_{I}B_{I}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/83bedeaa612fd552fb7c19a3ac2982da43509098).






d
[
A
]

/

d
t
=
−

k

2


[
A
]
[
C
]


{\textstyle d[A]/dt=-k\_{2}[A][C]}

![{\textstyle d[A]/dt=-k_{2}[A][C]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/499e9560688bc44d9b6db5fcf03e37c0f1099e4b)






d
[

B

i


]

/

d
t
=

n

i



k

2


[
A
]
[
C
]


{\textstyle d[B\_{i}]/dt=n\_{i}k\_{2}[A][C]}

![{\textstyle d[B_{i}]/dt=n_{i}k_{2}[A][C]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/71d36527854a31a5f58dc8b10a7b7a32dd9fbb32), 



i
=
1
,
.
.
.
,
I


{\textstyle i=1,...,I}

![{\textstyle i=1,...,I}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7293273f9bd64c3c4f26016ba6dd0da2ea708b3d).
3. The simplest example of oscillating chemical system is the Oregonator [[1]](http://www.scholarpedia.org/article/Oregonator), which consists of the following reactions:






A
+
Y

→


k

1




X
+
P


{\textstyle A+Y\xrightarrow {k\_{1}} X+P}

![{\textstyle A+Y\xrightarrow {k_{1}} X+P}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f328178457877f46c5c421929f12597782602afc).






X
+
Y

→


k

2




2
P


{\textstyle X+Y\xrightarrow {k\_{2}} 2P}

![{\textstyle X+Y\xrightarrow {k_{2}} 2P}](https://wikimedia.org/api/rest_v1/media/math/render/svg/87e453e5708ca44c1224d7bc1d750fbdd9d2a239).






A
+
X

→


k

3




2
X
+
2
Z


{\textstyle A+X\xrightarrow {k\_{3}} 2X+2Z}

![{\textstyle A+X\xrightarrow {k_{3}} 2X+2Z}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3080f082392f170363230c6a3dfb719968255960).






2
X

→


k

4




A
+
P


{\textstyle 2X\xrightarrow {k\_{4}} A+P}

![{\textstyle 2X\xrightarrow {k_{4}} A+P}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4e0f91115b5d53ac68b142dbc49b9f87b9b53934).






B
+
Z

→


k

5




Y


{\textstyle B+Z\xrightarrow {k\_{5}} Y}

![{\textstyle B+Z\xrightarrow {k_{5}} Y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0ab46f36791379c41275db2de82bfe63b533e5ae).


The reaction rates will always be within order of magnitude from their respective values in the example input file.


Input


The first line contains a single integer number 



T


{\textstyle T}

![{\textstyle T}](https://wikimedia.org/api/rest_v1/media/math/render/svg/db299e88e5485f250f4ba15530469c8c6080a8cb) = 1...1000 – how long we will run our virtual reactor. The second line contains six floating-point values – the initial concentrations of 



X


{\textstyle X}

![{\textstyle X}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8d80c41192705e1a6c6de1d65e16d7f70fbac391), 



Y


{\textstyle Y}

![{\textstyle Y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6222becc4f0c5effa012e5335b170575fdbbaad3), 



Z


{\textstyle Z}

![{\textstyle Z}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d442d6fe240625e70b574360ee971066244df646), 



A


{\textstyle A}

![{\textstyle A}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a118c6ad00742b3f5dccd2f0e74b5e369df6fd31), 



B


{\textstyle B}

![{\textstyle B}](https://wikimedia.org/api/rest_v1/media/math/render/svg/de0b47ffc21636dc2df68f6c793177a268f10e9b) and 



P


{\textstyle P}

![{\textstyle P}](https://wikimedia.org/api/rest_v1/media/math/render/svg/038590207af1024a629c1a08c855e9ac46bf5610). The third line contains five floating-point values – the reaction rate constants 




k

1


,
.
.
.
,

k

5




{\textstyle k\_{1},...,k\_{5}}

![{\textstyle k_{1},...,k_{5}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d96ba4798fd41231b014e0b6894e734a9579dda2).


Output


The output should contains six floating-point values – the final concentrations of 



X


{\textstyle X}

![{\textstyle X}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8d80c41192705e1a6c6de1d65e16d7f70fbac391), 



Y


{\textstyle Y}

![{\textstyle Y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6222becc4f0c5effa012e5335b170575fdbbaad3), 



Z


{\textstyle Z}

![{\textstyle Z}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d442d6fe240625e70b574360ee971066244df646), 



A


{\textstyle A}

![{\textstyle A}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a118c6ad00742b3f5dccd2f0e74b5e369df6fd31), 



B


{\textstyle B}

![{\textstyle B}](https://wikimedia.org/api/rest_v1/media/math/render/svg/de0b47ffc21636dc2df68f6c793177a268f10e9b) and 



P


{\textstyle P}

![{\textstyle P}](https://wikimedia.org/api/rest_v1/media/math/render/svg/038590207af1024a629c1a08c855e9ac46bf5610). Required precision is 




10

−


6


{\textstyle 10^{-}6}

![{\textstyle 10^{-}6}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0d82cff3cabaf196e52510b9a8c994a41c9053ff).


Exams and retake planning
-------------------------


### Exam


Exams will be project-based and will be conducted in a form of problem solving, where the problems will be similar to those mentioned above. Students will be given 1-2 weeks to complete the exam.



### Retake 1


First retake will be paper-based and will be conducted in a form of problem solving. Students will be given 2-3 hours to complete the exam.The weight of the retake exam will be the same as the all course.



### Retake 2


Second retake will be paper-based and will be conducted in a form of problem solving. Students will be given 2-3 hours to complete the exam.The weight of the retake exam will be the same as the all course.











