






BSc: Advanced Linux
===================






Contents
--------


* [1 Advanced Linux](#Advanced_Linux)
	+ [1.1 Short Description](#Short_Description)
	+ [1.2 Prerequisites](#Prerequisites)
		- [1.2.1 Prerequisite subjects](#Prerequisite_subjects)
		- [1.2.2 Prerequisite topics](#Prerequisite_topics)
	+ [1.3 Course Topics](#Course_Topics)
	+ [1.4 Intended Learning Outcomes (ILOs)](#Intended_Learning_Outcomes_.28ILOs.29)
		- [1.4.1 What is the main purpose of this course?](#What_is_the_main_purpose_of_this_course.3F)
		- [1.4.2 ILOs defined at three levels](#ILOs_defined_at_three_levels)
			* [1.4.2.1 Level 1: What concepts should a student know/remember/explain?](#Level_1:_What_concepts_should_a_student_know.2Fremember.2Fexplain.3F)
			* [1.4.2.2 Level 2: What basic practical skills should a student be able to perform?](#Level_2:_What_basic_practical_skills_should_a_student_be_able_to_perform.3F)
			* [1.4.2.3 Level 3: What complex comprehensive skills should a student be able to apply in real-life scenarios?](#Level_3:_What_complex_comprehensive_skills_should_a_student_be_able_to_apply_in_real-life_scenarios.3F)
	+ [1.5 Grading](#Grading)
		- [1.5.1 Course grading range](#Course_grading_range)
		- [1.5.2 Course activities and grading breakdown](#Course_activities_and_grading_breakdown)
		- [1.5.3 Recommendations for students on how to succeed in the course](#Recommendations_for_students_on_how_to_succeed_in_the_course)
	+ [1.6 Resources, literature and reference materials](#Resources.2C_literature_and_reference_materials)
		- [1.6.1 Open access resources](#Open_access_resources)
		- [1.6.2 Closed access resources](#Closed_access_resources)
		- [1.6.3 Software and tools used within the course](#Software_and_tools_used_within_the_course)
* [2 Teaching Methodology: Methods, techniques, & activities](#Teaching_Methodology:_Methods.2C_techniques.2C_.26_activities)
	+ [2.1 Activities and Teaching Methods](#Activities_and_Teaching_Methods)
	+ [2.2 Formative Assessment and Course Activities](#Formative_Assessment_and_Course_Activities)
		- [2.2.1 Ongoing performance assessment](#Ongoing_performance_assessment)
			* [2.2.1.1 Section 1](#Section_1)
			* [2.2.1.2 Section 2](#Section_2)
			* [2.2.1.3 Section 3](#Section_3)
			* [2.2.1.4 Section 4](#Section_4)
			* [2.2.1.5 Section 5](#Section_5)
			* [2.2.1.6 Section 6](#Section_6)
			* [2.2.1.7 Section 7](#Section_7)
			* [2.2.1.8 Section 8](#Section_8)
			* [2.2.1.9 Section 9](#Section_9)
		- [2.2.2 Final assessment](#Final_assessment)
		- [2.2.3 The retake exam](#The_retake_exam)



Advanced Linux
==============


* **Course name**: Advanced Linux
* **Code discipline**: xxxxx
* **Subject area**:


Short Description
-----------------


This course covers the following concepts: The fundamental principles for `booting`; Linux Kernel: understanding, programming, debugging, contributing; Device drivers; Power management; Graphical stack overview; Userspace: understating and interaction with Kernel, debugging userspace application and libraries.



Prerequisites
-------------


### Prerequisite subjects


### Prerequisite topics


Course Topics
-------------




Course Sections and Topics
| Section | Topics within the section
 |
| --- | --- |
| X86/Arm assembler introduction | 1. Basic assembler: registers, operations
2. x86 ABI reference
3. Context switching
4. CPU security rings
 |
| Userspace | 1. Executable files overview
2. ELF format
3. SO format
4. POSIX API
 |
| Userspace debugging (GDB) | 1. Debugging techniques overview
2. GDB (Gnu debugger) usage
3. Stack trace
4. Watchpoints/breakpoints
 |
| Linux Kernel introduction | 1. Kernel usage
2. Supported HW
3. Building the kernel
 |
| Booting the Kernel | 1. Boot Sequence
2. Device Tree
3. U-boot
4. initrd/initramfs
 |
| Kernel Modules | 1. Linux device and driver m​odel
2. Virtual Filesystems
 |
| Memory management | 1. Physical Memory
2. Virtual Memory
3. Memory Allocation
 |
| Threads, processes and scheduling | 1. Thread
2. Processes
3. Timers
 |
| Concurrent access to resources | 1. Mutexes
2. Spin locks
3. RW-locks
 |


Intended Learning Outcomes (ILOs)
---------------------------------


### What is the main purpose of this course?


The main purpose of this course is to give the students advanced knowledge of how Linux operation system boots, works and what parts it is consists of.



### ILOs defined at three levels


#### Level 1: What concepts should a student know/remember/explain?


By the end of the course, the students should be able to ...



* Principles of Operating Systems.
* Principles of bootloaders (first- /second- stage).
* Linux booting principles.
* Linux Kernel and apps debugging principles.


#### Level 2: What basic practical skills should a student be able to perform?


By the end of the course, the students should be able to ...



* Memory management in Kernel and userspace.
* Linux kernel subsustems.
* Concurrent access to resources.
* HW devices interaction in Linux.
* Interrupt and multithreading execution.
* Real- and virtual- filesystems interaction.


#### Level 3: What complex comprehensive skills should a student be able to apply in real-life scenarios?


By the end of the course, the students should be able to ...



* Kernel drivers design skills.
* Linux Kernel contribution and advanced GIT knowledge.
* C language low-level Kernel programming.
* C/C++ language system programming.
* POSIX API usage.
* Kernel and userspace debugging (including KGDB/GDB).
* x86/ARM assembly programming.


Grading
-------


### Course grading range





| Grade | Range | Description of performance
 |
| --- | --- | --- |
| A. Excellent | 100-150 | -
 |
| B. Good | 80-100 | -
 |
| C. Satisfactory | 60-79 | -
 |
| D. Poor | 0-59 | -
 |


### Course activities and grading breakdown





| Activity Type | Percentage of the overall course grade
 |
| --- | --- |
| Labs/seminar classes | 100
 |
| Interim performance assessment | 0
 |
| Exams | 50
 |


### Recommendations for students on how to succeed in the course


Resources, literature and reference materials
---------------------------------------------


### Open access resources


* Writing Kernel Module: i2c -
* Fundamental Linux Kernel programming by Krishenko V.A., Rayzanova N.U. - /
* Linux Operating System by Kuryachiy G.V., Malinskiy K.A. -
* Systemd after 10 years, historical and techical review, -
* Evolution of Linux Kernel by Novikov E.M., -
* Online resources shared by instructor


### Closed access resources


### Software and tools used within the course


Teaching Methodology: Methods, techniques, & activities
=======================================================


Activities and Teaching Methods
-------------------------------




Activities within each section
| Learning Activities | Section 1 | Section 2 | Section 3 | Section 4 | Section 5 | Section 6 | Section 7 | Section 8 | Section 9
 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Development of individual parts of software product code | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
 |
| Homework and group projects | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0
 |
| Midterm evaluation | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0
 |
| Testing (written or computer based) | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
 |
| Discussions | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
 |


Formative Assessment and Course Activities
------------------------------------------


### Ongoing performance assessment


#### Section 1





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | ARM architecture is faster than x86, itn’s it? | 1
 |
| Question | Why does antivirus software works in RING0? | 1
 |
| Question | What is the main purpose of having interrupts? | 1
 |
| Question | How-to debug anything inside interrupt context? | 1
 |
| Question | Show the difference in x86 and ARM CPU registers. | 0
 |
| Question | Create `basic` atomic operations for ARM in x86 (and vice versa). | 0
 |
| Question | Implement simple context switching without threads. | 0
 |


#### Section 2





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | Why can’t we just use .EXE and .DLL files on Linux? | 1
 |
| Question | Do .SO files actually share same memory physical addresses? | 1
 |
| Question | POSIX vs WinAPI? Which is better from portability point of view? | 1
 |
| Question | What is the most secure method for interprocess communication? | 1
 |
| Question | What is the fastest method for interprocess communication? | 1
 |
| Question | Create simple app for ELF format parsing. | 0
 |
| Question | Create app that shows dependencies between .so and executable file. | 0
 |
| Question | Create two apps communicating with each other. At least 2 methods. Compare the speed. | 0
 |
| Question | Create app with joinable and detachable threads. Check the difference. | 0
 |
| Question | Create app that uses fork() and execve() with controlling child process. | 0
 |


#### Section 3





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | What is GDB? What platforms can be debugged using GDB? | 1
 |
| Question | Do we have any alternatives for GDB? | 1
 |
| Question | What should we have related to the app to debug it in GDB? | 1
 |
| Question | Name popular GDB front-ends. Check what front-ends for GDB you already use. | 1
 |
| Question | What alternatives to GHIDRA do we have for different platforms? | 1
 |
| Question | Debug simple app using GDB with symbols in runtime. Use breakpoints and watchpoints and step by step debugging. | 0
 |
| Question | Load coredump and debug it in GDB. | 0
 |
| Question | Fix few variables in binary file using GHIDRA without source code. | 0
 |


#### Section 4





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | Monolithic kernel vs Micro-kernel. What is faster and why? | 1
 |
| Question | How Linux works on HW without IOMMU? | 1
 |
| Question | Tools required for building Linux Kernel. | 1
 |
| Question | Name few operations systems bases on Linux and name the difference. | 1
 |
| Question | Contributing to Open Source software and Kernel. What is the difference? | 0
 |
| Question | Git usage: commits, email-patches. | 0
 |
| Question | Git usage: rewriting history. | 0
 |
| Question | Building Linux Kernel for your own PC. | 0
 |
| Question | Running new Kernel on your machine. | 0
 |
| Question | Kernel config file location and editing. | 0
 |


#### Section 5





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | What is the difference between BIOS and UEFI? What we prefer in nowadays? | 1
 |
| Question | What is the usage for secure boot? What requirements should be met for this? | 1
 |
| Question | Why in x86 we do not have device tree? And why is it required for ARM platforms? | 1
 |
| Question | What is the purpose of having initramfs? Can we skip that stage? | 1
 |
| Question | Build U-boot | 0
 |
| Question | Rebuilding initramfs | 0
 |
| Question | Changing boot order of your PC. Creating simple systemd service. | 0
 |


#### Section 6





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | How kernel module can be compiled and used inside or outside Linux Kernel Image? | 1
 |
| Question | What is the purpose of System.map file for correct Linux Kernel functionality? | 1
 |
| Question | What is the real requirement to have virtual filesystems in Linux Kernel? | 1
 |
| Question | Name few real and virtual filesystems. Briefly describe usage in real life. | 1
 |
| Question | Develop and deploy simple Kernel Module outside kernel image. Dynamic Loading. | 0
 |
| Question | Develop and deploy simple Kernel Module inside kernel image. | 0
 |
| Question | SysFS/ DebugFS / ProcFS/ TmpFS usage | 0
 |


#### Section 7





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | Why do we need virtual memory? | 1
 |
| Question | Why does Linux Kernel maps itself to every process address space? | 1
 |
| Question | How does page fault handler work? | 1
 |
| Question | What is segmentation fault and how it handles in Linux Kernel? | 1
 |
| Question | Create simple allocator (myalloc/myfree). | 0
 |
| Question | Create benchmark for simple allocator. | 0
 |


#### Section 8





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | What is the difference between thread and process? | 1
 |
| Question | Can process exist without any threads? | 1
 |
| Question | What scheduling methods does Linux Kernel has? | 1
 |
| Question | What make `realtime` OS really realtime? | 1
 |
| Question | What is the difference between cooperative and preemptive multitasking? | 1
 |
| Question | Implement your own threads inside app. | 0
 |
| Question | Implement simple scheduler for your threading app. | 0
 |
| Question | Implement timer for your app without using `real` timers. | 0
 |


#### Section 9





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | Why do we need locking structures? | 1
 |
| Question | Where is mutex preferred on spinlock? | 1
 |
| Question | Where is spinlock preferred on mutex? | 1
 |
| Question | Can we just write locking-free code? | 1
 |
| Question | What is deadlock and how it could be handled? | 1
 |
| Question | Implement simple locking structures. | 0
 |
| Question | Implement Wait-die lock. | 0
 |


### Final assessment


**Section 1**



1. Describe basic CPU registers and their purpose.
2. Describe x86 ABI.
3. What is context switching and how does it work?
4. Name all CPU security rings and describe security levels.
5. Interrupts. Interrupt handler.


**Section 2**



1. Describe ELF executable format.
2. Describe how Linux processes could be load from ELF file.
3. Describe .SO library loading and their layout in memory.
4. Describe methods of interprocess communication (at least 2).
5. POSIX. Describe network operations.
6. POSIX. Describe pthread library.
7. POSIX. Describe time operations.
8. Describe select(), poll() methods. Name the difference.
9. POSIX. Describe filesystem operations.


**Section 3**



1. GDB. Why do we need to have symbols? Can we debug without them?
2. GDB. Describe debugging techniques only using coredump.
3. GDB. Describe usage or breakpoints and watchpoints.
4. GDB/GDB Server. Remote debugging. Describe how to do that.
5. GDB. Describe multiarch debugging.
6. GDB. Describe how to debug multithreaded application.
7. GDB. Stack trace. Describe usage and how-to.
8. GHIDRA. Describe usage flow.


**Section 4**



1. Briefly describe modern OS architecture. (for ex. Linux)
2. Describe supported HW by Linux Kernel.
3. Describe contribution process to Linux Kernel.


**Section 5**



1. Name popular bootloaders and briefly describe the difference.
2. Describe all boot sequence starting from pushing START button.
3. Describe in details the role of initrd/initramfs in booting process.
4. First userspace process. Describe how it works and why do we need SystemV/system?


**Section 6**



1. Describe Linux device and driver model
2. Real- and Virtual- filesystems. Describe in details.
3. Name other Linux Kernel subsystems and their usage.


**Section 7**



1. Describe how virtual memory maps on physical memory.
2. Describe in details how TLB works. How TLB increases memory operations?
3. Describe structure of page table, its location and management from OS.
4. Describe memory allocation techniques. Describe one of them in details.


**Section 8**



1. Describe how threading works.
2. Describe pthread API usage.
3. Describe difference between monotomic and realtime clocks.
4. Describe scheduling strategies. Make a suggestion, which one is preferred for different situations.
5. Describe difference in memory management between threads and processes.


**Section 9**



1. Describe mutex internals.
2. Describe spin lock internals.
3. Describe deadlock problem and how it could be handled.
4. Compare different locking methods and make conclusion of which is faster and why.
5. Deeply describe wait-die locks.
6. P.1.2.10 Section 10
7. Section title: Kernel debugging
8. Topics covered in this section:
9. Debugging techniques
10. DebugFS
11. Other methods overview (J-Tag etc).
12. KGDB
13. What forms of evaluation were used to test students’ performance in this section?
14. Typical questions for ongoing performance evaluation within this section
15. Name and briefly describe kernel-debugging techniques.
16. What debug levels for printk do you know and what is their usage?
17. What other methods of Kernel debugging techniques do you know?
18. Why can’t we use regular GDB to debug Linux Kernel?
19. Typical questions for seminar classes (labs) within this section
20. Usage of DebugFS for basic debugging
21. Usage of printk and debug levels.
22. KGDB usage for Kernel debugging.
23. Test questions for final assessment in this section
24. Explain usage of debugFS in modern kernels.
25. Describe main kernel debugging techniques.
26. P.1.2.11 Section 11
27. Section title: HW busses
28. Topics covered in this section:
29. GPIO
30. UART
31. i2c
32. spi
33. pin muxing
34. DMA
35. What forms of evaluation were used to test students’ performance in this section?
36. Typical questions for ongoing performance evaluation within this section
37. What HW bus type should we prefer for flash memory?
38. What bus is the fastest?
39. What should we do if we don’t have enough available pins for our needs?
40. Can spi devices be connected in parallel? How can we do that?
41. DMA – overkill technique or our current basic needs? Briefly review advantages and disadvantages of DMA.
42. Typical questions for seminar classes (labs) within this section
43. Implement connection to other device using UART. Exchange data.
44. Note: additional tasks will be given depends on current HW availability.
45. Test questions for final assessment in this section
46. Describe i2c bus. Usage of i2c bus.
47. Describe spi bus. Usage of spi bus.
48. Describe GPIO subsystem. Usage of GPIO.
49. Describe pin muxing.
50. Describe usage of DMA and consider exchange speed with and without DMA.
51. P.1.2.12 Section 12
52. Section title: PCI
53. Topics covered in this section:
54. PCI Physical parameters
55. PCI Electrical parameters
56. PCI Logical model
57. PCI Configuration
58. What forms of evaluation were used to test students’ performance in this section?
59. Typical questions for ongoing performance evaluation within this section
60. Briefly describe PCI specification.
61. What is difference between PCI and PCIe?
62. Name devices that could be connected to PC using PCI bus.
63. Device tree and PCI. Briefly describe how we can configure them.
64. Typical questions for seminar classes (labs) within this section
65. Measure PCI Ex bus speed with different connection types: x1, x2, x4 and x16.
66. Test questions for final assessment in this section
67. Describe parameters of PCI bus interface.
68. Describe usage of PCI bus in modern PC/laptop.
69. Describe configuration and enumeration of devices on PCI bus.
70. P.1.2.13 Section 13
71. Section title: USB
72. Topics covered in this section:
73. USB Physical parameters
74. USB Electrical parameters
75. USB Logical model
76. USB Configuration and enumeration
77. What forms of evaluation were used to test students’ performance in this section?
78. Typical questions for ongoing performance evaluation within this section
79. Briefly describe USB specification.
80. USB/A/B – type C. Describe difference.
81. What devices could be connected using USB bus?
82. Why we do not reboot after USB device connection to discover it?
83. Can we add USB devices to device tree for faster enumeration?
84. Typical questions for seminar classes (labs) within this section
85. Implement simple USB device driver for keyboard/flash card/mouse etc.
86. Test questions for final assessment in this section
87. Describe parameters of USB interface.
88. Describe usage of USB in modern PC/laptop.
89. Describe configuration and enumeration of devices on USB.
90. P.1.2.14 Section 14
91. Section title: Graphical Stack overview
92. Topics covered in this section:
93. Framebuffer
94. X11
95. Wayland
96. UI interfaces: GTK/Qt
97. What forms of evaluation were used to test students’ performance in this section?
98. Typical questions for ongoing performance evaluation within this section
99. Linux- and Windows- comparison of graphical stack.
100. Can we access framebuffer when it is double- or triple- buffered?
101. What part of OS owns framebuffer?
102. How X11 knows when to redraw on screen info?
103. Can we use X11 and Wayland together?
104. Typical questions for seminar classes (labs) within this section
105. Create app with direct access to framebuffer.
106. Use X11 forwarding using SSH tunnel.
107. Create simple GTK/Qt application.
108. Test questions for final assessment in this section
109. Describe the usage of framebuffer.
110. Describe the purpose of X11 system.
111. Describe the purpose and advantages of Wayland framework.


### The retake exam


**Section 1**


**Section 2**


**Section 3**


**Section 4**


**Section 5**


**Section 6**


**Section 7**


**Section 8**


**Section 9**











