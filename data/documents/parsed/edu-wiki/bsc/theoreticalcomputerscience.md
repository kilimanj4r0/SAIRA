






BSc: Theoretical Computer Science
=================================



(Redirected from [BSc:TheoreticalComputerScience](/index.php?title=BSc:TheoreticalComputerScience&redirect=no "BSc:TheoreticalComputerScience"))


Contents
--------


* [1 Theoretical Computer Science](#Theoretical_Computer_Science)
	+ [1.1 Short Description](#Short_Description)
	+ [1.2 Prerequisites](#Prerequisites)
		- [1.2.1 Prerequisite subjects](#Prerequisite_subjects)
		- [1.2.2 Prerequisite topics](#Prerequisite_topics)
	+ [1.3 Course Topics](#Course_Topics)
	+ [1.4 Intended Learning Outcomes (ILOs)](#Intended_Learning_Outcomes_.28ILOs.29)
		- [1.4.1 What is the main purpose of this course?](#What_is_the_main_purpose_of_this_course.3F)
		- [1.4.2 ILOs defined at three levels](#ILOs_defined_at_three_levels)
			* [1.4.2.1 Level 1: What concepts should a student know/remember/explain?](#Level_1:_What_concepts_should_a_student_know.2Fremember.2Fexplain.3F)
			* [1.4.2.2 Level 2: What basic practical skills should a student be able to perform?](#Level_2:_What_basic_practical_skills_should_a_student_be_able_to_perform.3F)
			* [1.4.2.3 Level 3: What complex comprehensive skills should a student be able to apply in real-life scenarios?](#Level_3:_What_complex_comprehensive_skills_should_a_student_be_able_to_apply_in_real-life_scenarios.3F)
	+ [1.5 Grading](#Grading)
		- [1.5.1 Course grading range](#Course_grading_range)
		- [1.5.2 Course activities and grading breakdown](#Course_activities_and_grading_breakdown)
		- [1.5.3 Recommendations for students on how to succeed in the course](#Recommendations_for_students_on_how_to_succeed_in_the_course)
	+ [1.6 Resources, literature and reference materials](#Resources.2C_literature_and_reference_materials)
		- [1.6.1 Open access resources](#Open_access_resources)
		- [1.6.2 Closed access resources](#Closed_access_resources)
		- [1.6.3 Software and tools used within the course](#Software_and_tools_used_within_the_course)
* [2 Teaching Methodology: Methods, techniques, & activities](#Teaching_Methodology:_Methods.2C_techniques.2C_.26_activities)
	+ [2.1 Activities and Teaching Methods](#Activities_and_Teaching_Methods)
	+ [2.2 Formative Assessment and Course Activities](#Formative_Assessment_and_Course_Activities)
		- [2.2.1 Ongoing performance assessment](#Ongoing_performance_assessment)
			* [2.2.1.1 Section 1](#Section_1)
			* [2.2.1.2 Section 2](#Section_2)
			* [2.2.1.3 Section 3](#Section_3)
		- [2.2.2 Final assessment](#Final_assessment)
		- [2.2.3 The retake exam](#The_retake_exam)



Theoretical Computer Science
============================


* **Course name**: Theoretical Computer Science
* **Code discipline**: BS-
* **Subject area**:


Short Description
-----------------


This course covers the following concepts: Automata Theory; Formal Grammars; Computability.



Prerequisites
-------------


### Prerequisite subjects


* CSE113 Logic and Discrete Mathematics: set theory, inductive definitions and proofs, predicate logic, proof techniques (for example by contradiction, diagonalization...), algebraic structures (preferably).


### Prerequisite topics


Course Topics
-------------




Course Sections and Topics
| Section | Topics within the section
 |
| --- | --- |
| Automata Theory | 1. Languages
2. Finite State Automata
3. Pushdown Automata
4. Nondeterminism
5. Turing Machines
 |
| Formal Grammars | 1. Chomsky Hierarchy
2. Regular Expressions
3. Relationships with Automata
 |
| Computability | 1. Undecidability
2. Halting Problem
3. Rice Theorem
 |


Intended Learning Outcomes (ILOs)
---------------------------------


### What is the main purpose of this course?


A good software developer ignorant of how the mechanics of a compiler works is not better than a good pilot when it comes to fix the engine and he will definitively not be able to provide more than average solutions to the problems he is employed to solve. Like automotive engineering teach us, races can only be won by the right synergy of a good driving style and mechanics. Most importantly, limits of computation cannot be ignored in the same way we precisely know how accelerations, forces and frictions prevent us from racing at an unlimited speed. This course will investigate the prerequisites to understand compilers functioning. Although the act of compilation appears deceptively simple to most of the modern developers, great minds and results are behind the major achievements that made this possible. All starts with the Epimenides paradox (about 600 BC), which emphasizes a problem of self-reference in logic and brings us to the short time window between WWI and WW2 when, in 1936, Alan Turing proved that a general procedure to identify algorithm termination simply does not exist. Another major milestone has been reached by Noam Chomsky in 1956 with his description of a hierarchy of grammars. In this long historical timeframe we can put most of the bricks with which we build modern compilers. The course will be an historical tour through the lives of some of the greatest minds who ever lived on this planet.



### ILOs defined at three levels


#### Level 1: What concepts should a student know/remember/explain?


By the end of the course, the students should be able to ...



* Define a formal language
* List different computational models
* Define computational models such as Finite State Automata and Pushdown Automata
* List different types of Formal Grammars
* Define computability and related concepts
* List applications for automata theory and formal grammar


#### Level 2: What basic practical skills should a student be able to perform?


By the end of the course, the students should be able to ...



* Describe the basic mathematical machinery behind automata theory and how can be applied to programming languages compilers
* Explain Strengths and weaknesses of specific computational model
* Explain Finite State Automata and Pushdown Automata
* Abstract systems using the given models


#### Level 3: What complex comprehensive skills should a student be able to apply in real-life scenarios?


By the end of the course, the students should be able to ...



* Formally modelling a system
* Reasoning about verification of program properties
* Specifying a system as Finite State Automata, Pushdown Automata or Turing Machine
* Coding in programming languages an emulator of Finite State Automata
* Using proof techniques by diagonalization


Grading
-------


### Course grading range





| Grade | Range | Description of performance
 |
| --- | --- | --- |
| A. Excellent | 80-100 | -
 |
| B. Good | 65-79 | -
 |
| C. Satisfactory | 50-64 | -
 |
| D. Poor | 0-49 | -
 |


### Course activities and grading breakdown





| Activity Type | Percentage of the overall course grade
 |
| --- | --- |
| Labs/seminar classes | 40
 |
| Interim performance assessment | 30
 |
| Exams | 30
 |


### Recommendations for students on how to succeed in the course


Resources, literature and reference materials
---------------------------------------------


### Open access resources


* Handouts supplied by the instructor


### Closed access resources


### Software and tools used within the course


Teaching Methodology: Methods, techniques, & activities
=======================================================


Activities and Teaching Methods
-------------------------------




Activities within each section
| Learning Activities | Section 1 | Section 2 | Section 3
 |
| --- | --- | --- | --- |
| Development of individual parts of software product code | 1 | 0 | 0
 |
| Homework and group projects | 1 | 0 | 0
 |
| Midterm evaluation | 1 | 1 | 1
 |
| Testing (written or computer based) | 1 | 0 | 0
 |
| Reports | 1 | 1 | 0
 |
| Discussions | 1 | 1 | 1
 |


Formative Assessment and Course Activities
------------------------------------------


### Ongoing performance assessment


#### Section 1





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | What is a Finite State Automaton? | 1
 |
| Question | What is a Pushdown Automaton? | 1
 |
| Question | What is a Turing Machine? | 1
 |
| Question | What is a nondeterministic automaton? | 1
 |
| Question | Given a specific language define a corresponding Finite State Automaton | 1
 |
| Question | Given a specific language define a corresponding Pushdown Automaton | 1
 |
| Question | State the difference between Finite State Automata and Pushdown Automata | 1
 |
| Question | Computing the intersection, union, complement of two automata | 1
 |
| Question | What is Pumping Lemma? Example of applications. | 1
 |
| Question | Operations on Automata | 1
 |
| Question | Check if a given language is recognized by a specific Finite State Automaton | 0
 |
| Question | Prove with Pumping Lemma that a language is regular | 0
 |
| Question | Check if a given language is recognized by a specific Pushdown Automaton | 0
 |
| Question | Check if a given language is recognized by a specific Turing Machine | 0
 |
| Question | Define a correct automaton given a specific language | 0
 |


#### Section 2





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | What is Chomsky Hierarchy? | 1
 |
| Question | What is a Regular language? | 1
 |
| Question | What is a Context-free language? | 1
 |
| Question | What is a Context-sensitive language? | 1
 |
| Question | What is a regular expression? | 1
 |
| Question | Given a specific Finite State Automaton define a grammar for the corresponding language | 0
 |
| Question | Given a specific Pushdown Automaton define a grammar for the corresponding language | 0
 |
| Question | Given a regular expression design the corresponding Finite state Automaton | 0
 |
| Question | Given a Finite state Automaton define the regular expression for the corresponding language | 0
 |


#### Section 3





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | What is Halting Problem? | 1
 |
| Question | What is Rice theorem? | 1
 |
| Question | What is an undecidable problem | 1
 |
| Question | What is a Turing Machine? | 1
 |
| Question | What is Goedelization? | 1
 |
| Question | Given a specific computational problem showing that it is undecidable (via reduction to a known problem, for example) | 0
 |
| Question | Show a proof via diagonalization of Halting Problem | 0
 |
| Question | Show a proof via diagonalization of Rice Theorem | 0
 |
| Question | Give an example of an undecidable problem | 0
 |
| Question | Show that a Turing Machine with multiple tapes is equivalent to a Turing Machine with a single tape | 0
 |


### Final assessment


**Section 1**



1. Check if a given language is recognized by a specific Finite State Automaton
2. Prove with Pumping Lemma that a language is regular.
3. Check if a given language is recognized by a specific Pushdown Automaton
4. Check if a given language is recognized by a specific Turing Machine
5. Define a correct automaton given a specific language


**Section 2**



1. What is Chomsky Hierarchy?
2. What is a Regular language?
3. Given a regular expression design the corresponding Finite state Automaton
4. Given a specific Pushdown Automaton define a grammar for the corresponding language


**Section 3**



1. What is a Turing Machine?
2. What is Halting Problem?
3. What is Rice theorem?
4. Show a proof via diagonalization of Halting Problem
5. Show a proof via diagonalization of Rice Theorem
6. Show that a Turing Machine with multiple tapes is equivalent to a Turing Machine with a single tape


### The retake exam


**Section 1**


**Section 2**


**Section 3**











