






BSc: Advanced Compilers Construction and Program Analysis
=========================================================



(Redirected from [BSc:AdvancedCompilersConstructionandProgramAnalysis](/index.php?title=BSc:AdvancedCompilersConstructionandProgramAnalysis&redirect=no "BSc:AdvancedCompilersConstructionandProgramAnalysis"))


Contents
--------


* [1 Advanced Compilers Construction and Program Analysis](#Advanced_Compilers_Construction_and_Program_Analysis)
	+ [1.1 Short Description](#Short_Description)
	+ [1.2 Prerequisites](#Prerequisites)
		- [1.2.1 Prerequisite subjects](#Prerequisite_subjects)
		- [1.2.2 Prerequisite topics](#Prerequisite_topics)
	+ [1.3 Course Topics](#Course_Topics)
	+ [1.4 Intended Learning Outcomes (ILOs)](#Intended_Learning_Outcomes_.28ILOs.29)
		- [1.4.1 What is the main purpose of this course?](#What_is_the_main_purpose_of_this_course.3F)
* [2 Course Objectives Based on Bloom’s Taxonomy](#Course_Objectives_Based_on_Bloom.E2.80.99s_Taxonomy)
	+ [2.1 ILOs defined at three levels](#ILOs_defined_at_three_levels)
		- [2.1.1 Level 1: What concepts should a student know/remember/explain?](#Level_1:_What_concepts_should_a_student_know.2Fremember.2Fexplain.3F)
		- [2.1.2 Level 2: What basic practical skills should a student be able to perform?](#Level_2:_What_basic_practical_skills_should_a_student_be_able_to_perform.3F)
		- [2.1.3 Level 3: What complex comprehensive skills should a student be able to apply in real-life scenarios?](#Level_3:_What_complex_comprehensive_skills_should_a_student_be_able_to_apply_in_real-life_scenarios.3F)
	+ [2.2 Grading](#Grading)
		- [2.2.1 Course grading range](#Course_grading_range)
		- [2.2.2 Course activities and grading breakdown](#Course_activities_and_grading_breakdown)
		- [2.2.3 Recommendations for students on how to succeed in the course](#Recommendations_for_students_on_how_to_succeed_in_the_course)
	+ [2.3 Resources, literature and reference materials](#Resources.2C_literature_and_reference_materials)
		- [2.3.1 Open access resources](#Open_access_resources)
		- [2.3.2 Closed access resources](#Closed_access_resources)
		- [2.3.3 Software and tools used within the course](#Software_and_tools_used_within_the_course)
		- [2.3.4 Resources and reference material](#Resources_and_reference_material)
* [3 Teaching Methodology: Methods, techniques, & activities](#Teaching_Methodology:_Methods.2C_techniques.2C_.26_activities)
	+ [3.1 Activities and Teaching Methods](#Activities_and_Teaching_Methods)
	+ [3.2 Formative Assessment and Course Activities](#Formative_Assessment_and_Course_Activities)
		- [3.2.1 Ongoing performance assessment](#Ongoing_performance_assessment)
			* [3.2.1.1 Section 1](#Section_1)
			* [3.2.1.2 Section 2](#Section_2)
			* [3.2.1.3 Section 3](#Section_3)
			* [3.2.1.4 Section 4](#Section_4)
		- [3.2.2 Final assessment](#Final_assessment)
		- [3.2.3 The retake exam](#The_retake_exam)



Advanced Compilers Construction and Program Analysis
====================================================


* **Course name**: Advanced Compilers Construction and Program Analysis
* **Code discipline**: XYZ
* **Subject area**: Programming Languages and Software Engineering


Short Description
-----------------


This course covers the following concepts: Advanced Compilers Construction and Program Analysis concepts:


  

Key concepts of the class



* Type Systems
* Lambda calculi as the core representation
* Type checking and type inference
* Simple types and derived forms
* Subtyping
* Imperative objects
* Recursive types
* Universal polymorphism
* Compiling lazy functional languages


Prerequisites
-------------


### Prerequisite subjects


### Prerequisite topics


Course Topics
-------------




Course Sections and Topics
| Section | Topics within the section
 |
| --- | --- |
| Introduction to subject, computer networks basics, transport layer protocols, and socket programming | 1. General introduction to the course
2. Computer networks basic
3. Socket programming
4. UDP socket programming
5. TCP socket programming
 |
|  |  |
| Coordination, consistency, and replication in distributed systems |  |
| Fault tolerance and security in distributed systems |  |


Course Sections





The main sections of the course and approximate hour distribution between
them is as follows:
| Section Title | Lecture Hours | Seminars (labs) | Selfstudy | Knowledge evaluation
 |
| --- | --- | --- | --- | --- |
| Lambda Calculus and Simple Types | 10 | 10 | 10 | 2
 |
| References, Exceptions, Imperative Objects, Featheweight Java | 8 | 8 | 8 | 1
 |
| Recursive Types, Type Reconstruction, Universal Polymorphism | 6 | 6 | 6 | 1
 |
| Compiling Lazy Functional Languages | 8 | 8 | 8 | 1
 |
| Project Presentation |  |  |  | 2
 |


  



Section 1
Section title: Lambda calculus and simple types


Topics covered in this section:



* The history of typed languages. Type systems and language design.
* Basic notions: untyped lambda calculus, nameless representation, simple types.





| Form of evaluation | Usage |  |
| --- | --- | --- |
| Development of individual parts of software product code | 1 |  |
| Homework and group projects | 1 |  |
| Midterm evaluation | 0 |  |
| Testing (written or computer based) | 0 |  |
| Reports | 1 |  |
| Essays | 0 |  |
| Oral polls | 1 |  |
| Discussions | 1 |  |


  

Typical questions for ongoing performance evaluation within this section



* What is the role of the type system in language design?
* How to evaluate lambda terms using call-by-name/call-by-value strategies?
* What is the typing relation?
* What is type safety?
* What is erasure of types?
* What is general recursion?


Typical questions for seminar classes (labs) within this section



* Evaluate a given lambda expression using call-by-name strategy.
* Convert a given lambda expression to/from a nameless representation.
* Draw a type derivation tree for a given lambda term in simply typed lambda calculus.
* Provide a type for a given lambda term in a given simple type system.


Test questions for final assessment in this section



* Present an implementation of an interpreter for untyped lambda calculus.
* Present an implementation of a type checker for simply typed lambda


calculus.


  

Section 2
Section title: References, exceptions, imperative objects, Featherweight Java


  

Topics covered in this section:



* References, store typings, raising and handling exceptions
* Subsumption and the subtyping relation, coercion semantics, the Bottom Type
* Object-oriented programming and lambda calculus with imperative objects
* Featherweight Java


  







| Form of evaluation | Usage |  |
| --- | --- | --- |
| Development of individual parts of software product code | 1 |  |
| Homework and group projects | 1 |  |
| Midterm evaluation | 1 |  |
| Testing (written or computer based) | 0 |  |
| Reports | 1 |  |
| Essays | 0 |  |
| Oral polls | 1 |  |
| Discussions | 1 |  |


  

Typical questions for ongoing performance evaluation within this section



* How operational semantic changes when introducing references?
* How operational semantic changes when introducing exceptions?
* What is the concept of imperative objects?
* What are the features of Featherweight Java?
* Explain effects of call-by-name and call-by-value evaluation strategies on terms with references.


Typical questions for seminar classes (labs) within this section



* Evaluate given expression with references.
* Evaluate given expression with exceptions.
* Draw a type derivation tree for a given lambda term in simply typed


lambda calculus with references and exceptions.



* Provide a type for a given lambda term in a given simple type system with references and exceptions.


Test questions for final assessment in this section



* Present and/or explain an implementation of an interpreter for lambda calculus with references and exceptions.
* Present and/or explain an implementation of a type checker for simply typed lambda calculus with references and exceptions.


  

Section 3
Section title: Recursive types, type reconstruction, universal polymorphism


What forms of evaluation were used to test students’ performance in
this section?





Form of evaluation
| Form of evaluation | Usage |  |
| --- | --- | --- |
| Development of individual parts of software product code | 1 |  |
| Homework and group projects | 1 |  |
| Midterm evaluation | 0 |  |
| Testing (written or computer based) | 0 |  |
| Reports | 1 |  |
| Essays | 0 |  |
| Oral polls | 1 |  |
| Form of evaluation | Usage |  |
| Discussions | 1 |  |


  



Topics covered in this section:



* Recursive types, induction and coinduction, finite and infinite types
* Polymorphism, type reconstruction, universal types
* System F and Hindley-Milner type system


Typical questions for ongoing performance evaluation within this section



* What is the concept of recursive types?
* What is the motivation for universal types?
* Explain the differences between System F and Hindley-Milner type system.


Typical questions for seminar classes (labs) within this section



* Evaluate given expression in System F with recursive types.
* Draw a type derivation tree for a given term in System F.
* Provide a type for a given term in System F.


Test questions for final assessment in this section



* Present and/or explain an implementation of an interpreter for lambda calculus with references and exceptions.
* Present and/or explain an implementation of a type checker for simply typed lambda calculus with references and exceptions.
* Present and/or explain the Hindley-Milner type inference algorithm.


Section 4
Section title: Compiling lazy functional languages


Topics covered in this section:



* Challenges of compiling lazy functional languages
* Representing functional closures at run-time
* Representing lazy data structures at run-time
* The syntax and semantics of the STG language


What forms of evaluation were used to test students’ performance in
this section?





Form of evaluation
| Form of evaluation | Usage |  |
| --- | --- | --- |
| Development of individual parts of software product code | 1 |  |
| Homework and group projects | 1 |  |
| Midterm evaluation | 0 |  |
| Testing (written or computer based) | 0 |  |
| Reports | 1 |  |
| Essays | 0 |  |
| Oral polls | 1 |  |
| Form of evaluation | Usage |  |
| Discussions | 1 |  |


  



Typical questions for ongoing performance evaluation within this section



* How are closures represented during run-time?
* How are lazy data structures represented during run-time?
* Describe the main constructions of the STG Language?


Typical questions for seminar classes (labs) within this section



* Explain how a given term in STG language evaluates.
* Translate a given lambda term into STG language


Test questions for final assessment in this section



* Present and/or explain the STG machine.
* Present an implementation of a type checker for simply typed lambda


calculus.



Intended Learning Outcomes (ILOs)
---------------------------------


### What is the main purpose of this course?


This course partially covers two major topics:
1. Theory and Implementation of Typed Programming Languages and
2. Compilation of Lazy Functional Languages.
We will study different type system features in detail, starting from an untyped language of lambda calculus and gradually adding new types and variations along the way. The course assumes familiarity with basics of compiler construction, basics of functional programming and familiarity with some static type systems (C++ and Java would suffice, but knowing type systems of Haskell or Scala will help). 
Even though the most obvious benefit of static type systems is that it allows programmers to detect some errors early, it is by far not the only application. Types are used also as a tool for abstraction, documentation, language safety, efficiency and more. In this course we will look at features of type systems occurring in many programming languages, like C++, Java, Scala and Haskell. 
After we have reached System F, a type system at the core of languages like Haskell, we will look into how lazy functional languages are implemented. We will in particular look in detail at Spineless Tagless Graph reduction machine (also known as STG machine) that is used to compile Haskell code. 


Evaluation of the course consists of Lecture Quizzes, Lab Participation and the Final Project (split into several stages). The Final Project is a team project where students build a complete interpreter or compiler for a statically typed programming language, incorporating some of the features covered in this course.



Course Objectives Based on Bloom’s Taxonomy
===========================================


What should a student remember at the end of the course?



* Remember syntax and computation rules of untyped lambda calculus.
* Remember nameless representation of lambda terms.
* Remember definition of normal form, weak head normal form.
* Remember syntax, typing and computation rules of simply typed lambda calculus.
* Remember definition of imperative objects.
* Remember syntax and semantics of Featherweight Java.
* Remember typing rules for subtyping.
* Remember typing rules for pairs, tuples, records, sums, variants, and lists.
* Remember typing rules for let-bindings and type ascription.
* Remember typing rules for recursive types.
* Remember definition and typing rules for universal polymorphism.
* Remember syntax, typing and computation rules for System F.
* Remember representation of closures when compiling functional languages.
* Remember representation of lazy data structures when compiling.
* Remember the syntax and semantics of the STG language.


What should a student be able to understand at the end of the course?



* Understand how type systems relate to language design
* Understand differences between call-by-name, call-by-need, and call-byvalue evaluation strategies.
* Understand the tradeoffs introduced by various type system features.
* Understand the idea of nameless representation of terms.
* Understand the tradeoffs of mutable references and exceptions introduced in a language.
* Understand how imperative objects model objects in modern objectoriented langauges.
* Understand the difficulties of compiling lazy expressions.
* Understand the differences between Hindley–Milner type system and System F.


What should a student be able to apply at the end of the course?



* Implement an interpreter for a programming language with untyped lambda calculus as its core representation.
* Implement an interpreter for a programming language with simply typed lambda calculus as its core representation.
* Implement type checking algorithm for a language with simple types, recursive types, imperative objects, and universal polymorphism.
* Implement Damas–Hindley–Milner type inference algorithm for a programming language with a Hindley-Milner style type system.


Course evaluation:



* Labs/seminar classes (proposed points: 20)
* Interim performance assessment (proposed points: 10)
* Exams (proposed points: 70)


### ILOs defined at three levels


#### Level 1: What concepts should a student know/remember/explain?


By the end of the course, the students should be able to ...


  




#### Level 2: What basic practical skills should a student be able to perform?


By the end of the course, the students should be able to ...


  




#### Level 3: What complex comprehensive skills should a student be able to apply in real-life scenarios?


By the end of the course, the students should be able to ...



Grading
-------


### Course grading range





| Grade | Range | Description of performance
 |
| --- | --- | --- |
| A. Excellent | 85-100 | -
 |
| B. Good | 75-84 | -
 |
| C. Satisfactory | 60-74 | -
 |
| D. Poor | 0-59 | -
 |


### Course activities and grading breakdown





| Activity Type | Percentage of the overall course grade
 |
| --- | --- |
| Laboratory assignments | 55%
 |
| Final exam | 35%
 |
| Attendance | 10%
 |


### Recommendations for students on how to succeed in the course


Resources, literature and reference materials
---------------------------------------------


### Open access resources


* Textbook:. Available online:
* Reference:. Available online:
* Reference:. Available online:


### Closed access resources


### Software and tools used within the course


### Resources and reference material


* Benjamin C. Pierce. ’‘Types and Programming Languages. The MIT Press 2002”
* Simon Peyton Jones. ’‘Implementing functional languages: a tutorial. Prentice Hall 1992”
* Simon Peyton Jones. ’‘Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine. Journal of Functional Programming 1992”


Teaching Methodology: Methods, techniques, & activities
=======================================================


Activities and Teaching Methods
-------------------------------




Activities within each section
| Learning Activities | Section 1 | Section 2 | Section 3 | Section 4
 |
| --- | --- | --- | --- | --- |
| Development of individual parts of software product code | 1 | 1 | 1 | 1
 |
| Homework and group projects | 1 | 1 | 1 | 1
 |
| Testing (written or computer based) | 1 | 1 | 1 | 1
 |
| Oral polls | 1 | 1 | 1 | 1
 |
| Discussions | 1 | 1 | 1 | 1
 |


Formative Assessment and Course Activities
------------------------------------------


### Ongoing performance assessment


#### Section 1





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | ? | 1
 |
| Question | . | 1
 |
| Question | ? | 1
 |
| Question | ? | 1
 |
| Question | ? | 1
 |
| Question | ? | 1
 |
| Question | ? | 1
 |


#### Section 2





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | You have a list of large numbers, and you need to find if they are prime or not. Would you use multithreading, multiprocessing, or sequential programming in order to complete the task asap? Prove it in practice. | 0
 |
| Question | You need to send multiple requests to a server and receive responses. Assume there is a few msecs of delay before you receive the response from the server. Would you use multithreading, multiprocessing, or sequential programming in order to complete the task asap? Prove it in practice. (Order of the requests/responses doesn't matter) | 0
 |
| Question | Discuss two ways of creating the threads using threading module in Python: 1) passing the worker function as a target, 2) subclassing the Thread class | 0
 |
| Question | Given the function implemented locally, make it available to be called through RPC from remote process? Use xmlRPC. | 0
 |


#### Section 3





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | ? | 1
 |
| Question | ? | 1
 |
| Question | ? | 1
 |
| Question | ? | 1
 |
| Question | ? | 1
 |


#### Section 4





| Activity Type | Content | Is Graded?
 |
| --- | --- | --- |
| Question | Same as above | 0
 |


### Final assessment


**Section 1**



1. ?
2. ?
3. ?
4. ?


**Section 2**



1. 


**Section 3**


**Section 4**



1. Same as above


### The retake exam


**Section 1**


**Section 2**


**Section 3**


**Section 4**











